# Implementation Plan: UI Map & Discovery System

**Branch**: `001-ui-map-flow-engine` | **Date**: 2025-10-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-ui-map-flow-engine/spec.md`

**Note**: This plan was generated by `/speckit.plan` command based on comprehensive research and existing codebase analysis.

## Summary

Phase 1 implementation of UI Map & Discovery System for Android app automation. The system provides manual state discovery, automatic UI capture, graph building, and basic editing capabilities. Built as a React panel replacing the GPS functionality, with backend services for ADB-based UI introspection, JSON-based graph persistence, and REST API for state management.

## Technical Context

**Language/Version**: Node.js 20 (backend), React 18 with TypeScript (frontend)
**Primary Dependencies**: UIAutomator2 via ADB, Express.js, Zustand state management, Docker Compose
**Storage**: JSON files with Git version control (graph.json, sessions/*.jsonl, screenshots/*.png)
**Testing**: Jest (unit), Supertest (API integration), Playwright (E2E)
**Target Platform**: Linux containers with Android emulator (Docker Compose deployment)
**Project Type**: Web application with backend API and containerized Android integration
**Performance Goals**: Sub-1s state capture, <2s graph validation for 50 states, <500ms API responses p95
**Constraints**: <500 states, <2000 transitions, sub-1s capture times, offline-capable with local storage
**Scale/Scope**: Single app analysis (MaynDrive), 50-500 states per app, session-based discovery workflow

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

✅ **Container-Based Architecture**: All services run in Docker containers
✅ **WebRTC Streaming**: Leverages existing WebRTC infrastructure
✅ **No Public ADB/Frida Exposure**: Internal services only
✅ **Immutable Configuration**: Environment-based configuration
✅ **Structured Artifacts**: JSON files in mounted volumes
✅ **TypeScript Strict**: Maintains code quality standards
✅ **Health Endpoints**: /healthz for all services
✅ **Single Docker Compose**: No new infrastructure required

## Project Structure

### Documentation (this feature)

```text
specs/001-ui-map-flow-engine/
├── plan.md              # This file (filled by /speckit.plan)
├── research.md          # Phase 0 output - ADB/UI automation research
├── data-model.md        # Phase 1 output - Entity definitions
├── quickstart.md        # Phase 1 output - User guide
├── contracts/           # Phase 1 output - API specifications
│   ├── api.yaml        # OpenAPI specification
│   └── types.ts       # TypeScript type definitions
└── tasks.md             # Phase 2 output (NOT created by /speckit.plan)
```

### Source Code (repository root)

**Web application structure** (selected Option 2):

```text
backend/
├── src/
│   ├── types/                  # GraphQL/TypeScript types
│   │   └── graph.ts           # From contracts/types.ts
│   ├── services/               # Business logic
│   │   ├── introspectService.ts # UI state capture via ADB
│   │   ├── graphService.ts     # Graph management and merging
│   │   └── streamerService.ts # Existing WebRTC integration
│   ├── routes/                # API endpoints
│   │   ├── graph.ts           # New UI discovery API routes
│   │   └── health.ts         # Health check endpoints
│   ├── config/                # Configuration
│   │   ├── stream.ts          # Existing WebRTC config
│   │   └── discovery.ts       # Discovery system config
│   └── utils/                # Utility functions
│       ├── adb.ts             # ADB connection management
│       ├── xml.ts             # UI hierarchy processing
│       └── hash.ts            # State ID generation
├── tests/
│   ├── unit/                  # Unit tests for services
│   ├── integration/           # API integration tests
│   └── fixtures/             # Test data and mocks
└── dist/                     # Compiled JavaScript (production)

frontend/
├── src/
│   ├── components/apps/        # App-specific panels
│   │   ├── DiscoveryPanel.tsx # New discovery UI (replaces GPS)
│   │   └── FridaPanel.tsx     # Existing Frida controls
│   ├── hooks/                 # React hooks
│   │   ├── useDiscovery.ts    # Discovery API integration
│   │   ├── useGraph.ts        # Graph state management
│   │   └── useFridaControls.ts # Existing Frida hooks
│   ├── state/                 # Global state management
│   │   └── featureFlagsStore.ts # Feature flags (discovery=true)
│   └── components/           # Reusable UI components
│       └── StreamViewer.tsx    # Existing WebRTC stream
├── tests/                    # Frontend tests
└── dist/                     # Built static files (production)

data/                         # Docker volume for discovery artifacts
├── graph.json                # UI graph (states, transitions)
├── sessions/                 # Session logs (JSONL format)
│   └── 2025-10-25T*.jsonl
└── screenshots/              # State screenshots
    └── abc123def.png
```

**Structure Decision**: Web application pattern chosen based on existing backend/frontend separation, Docker Compose deployment, and need for WebRTC streaming integration. Discovery panel extends existing apps structure alongside FridaPanel.

## Implementation Components

### Phase 0: Research Complete ✅

**Research Findings** (see `research.md`):
- UIAutomator2 + ADB commands for sub-1s capture performance
- Parallel execution patterns for activity, XML, and screenshot capture
- XML normalization with volatile attribute stripping for stable hashing
- Selector prioritization: resource-id > content-desc > text > class
- Container-based ADB integration with connection pooling

### Phase 1: Core Implementation (Current Phase)

#### Backend Services

**Emulator Introspection Service** (`backend/src/services/introspectService.ts`):
```typescript
interface IntrospectionRequest {
  forceScreenshot?: boolean;
  timeout?: number;
}

interface IntrospectionResult {
  state: StateRecord;
  captureTime: number;
  merged: boolean;
}
```

**Key ADB Commands**:
```bash
# Activity detection (150-300ms)
adb shell dumpsys activity activities | grep topResumedActivity

# UI hierarchy (200-400ms)
adb exec-out uiautomator dump /dev/tty

# Screenshot (300-600ms)
adb exec-out screencap -p
```

**Graph Management Service** (`backend/src/services/graphService.ts`):
- State deduplication with Jaccard similarity (threshold: 0.9)
- Transition validation and evidence recording
- Graph statistics and performance monitoring
- File-based persistence with compaction

#### API Routes (`backend/src/routes/graph.ts`)

**REST Endpoints**:
```typescript
POST /api/graph/snapshot          // Capture current state
POST /api/graph/transition        // Create transition
POST /api/graph/merge            // Merge duplicate states
GET  /api/graph                 // Get complete graph
GET  /api/state/current          // Current state detection
GET  /api/state/:id             // Get specific state
GET  /api/state/:id/screenshot   // Get state screenshot
GET  /api/sessions               // List sessions
GET  /api/sessions/:id          // Get session events
```

**Response Time Targets**:
- State capture: <1s total
- Graph operations: <500ms p95
- File I/O: <100ms for typical graphs (<50 states)

#### Frontend Components

**Discovery Panel** (`frontend/src/components/apps/DiscoveryPanel.tsx`):
```typescript
interface DiscoveryPanelProps {
  className?: string;
}

const DiscoveryPanel: React.FC<DiscoveryPanelProps> = () => {
  const {
    graph,
    currentState,
    isCapturing,
    captureState,
    createTransition,
    mergeStates
  } = useDiscovery();

  // Panel sections: State, Elements, Actions, Graph Mini-map
};
```

**Layout**: Stream (left) + Discovery side-panel (right), replacing GPS panel

**Feature Flag Integration**:
```typescript
// Update featureFlagsStore.ts
export const useFeatureFlagsStore = create<FeatureFlagsState>((set) => ({
  enableFrida: false,
  discoveryPanel: true,  // Enable new functionality
  gpsPanel: false,       // Disable legacy GPS

  // ... existing methods
}));
```

#### Data Integration

**File Persistence**:
```typescript
// Graph structure in /app/data/graph.json
{
  "version": "1.0.0",
  "packageName": "fr.mayndrive.app",
  "states": [...],
  "transitions": [...],
  "stats": { /* performance metrics */ }
}
```

**Session Logging**:
```jsonl
{"id":"evt-1","timestamp":"2025-10-25T16:45:01.000Z","type":"state_capture","severity":"info","message":"Captured MainActivity","stateId":"abc123","data":{"captureDuration":750}}
```

### Configuration Updates

#### Docker Compose Changes

**Add data volume**:
```yaml
services:
  backend:
    # ... existing config
    volumes:
      - ./var/autoapp:/var/autoapp
      - emulator-home:/root/.android
      - discovery-data:/app/data  # NEW: Discovery artifacts
    # ... rest of config

volumes:
  emulator-home:
  discovery-data:  # NEW: Named volume for persistence
```

**Environment Variables**:
```bash
# Discovery system configuration
ENABLE_DISCOVERY=true
DISCOVERY_PANEL=true
GPS_PANEL=false
GRAPH_PATH=/app/data/graph.json
SESSIONS_DIR=/app/data/sessions
SCREENSHOTS_DIR=/app/data/screenshots
ADB_HOST=host.docker.internal
ANDROID_SERIAL=emulator-5554
```

#### Backend Health Endpoint

**Add /api/healthz**:
```typescript
app.get('/api/healthz', (req, res) => {
  const health = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    services: {
      adb: checkAdbConnection(),
      graph: checkGraphFile(),
      storage: checkStorageAccess()
    }
  };
  res.json(health);
});
```

### Phase 2 Preparation (Out of Scope for Current Implementation)

**Future Enhancements** (not implemented in Phase 1):
- Flow DSL authoring and intelligent replay
- Visual graph canvas with interactive editing
- Frida-assisted selectors for complex UI elements
- LLM-powered flow suggestion and optimization
- Advanced state comparison algorithms

## Acceptance Testing

### Phase 1 Validation Criteria

**Functional Tests**:
1. ✅ State capture completes <1s with valid activity and selectors
2. ✅ Duplicate states merge correctly (Jaccard similarity ≥0.9)
3. ✅ Transitions record action and evidence accurately
4. ✅ Graph JSON loads and validates successfully
5. ✅ Discovery panel integrates with existing WebRTC stream

**Performance Tests**:
1. ✅ 50-state graph validates in <2s
2. ✅ API responses <500ms p95
3. ✅ UI capture <1s including screenshot
4. ✅ Memory usage <100MB for typical graphs

**Integration Tests**:
1. ✅ Works with existing MaynDrive app installation
2. ✅ Compatible with existing Frida functionality
3. ✅ No impact on WebRTC streaming performance
4. ✅ Graceful handling of emulator disconnection

**Constitution Compliance Tests**:
1. ✅ All services run in containers
2. ✅ No external network dependencies for core functionality
3. ✅ JSON artifacts stored in mounted volumes
4. ✅ Health endpoints implemented
5. ✅ TypeScript strict mode maintained

## Risk Mitigation

### Technical Risks

**ADB Performance Risk**:
- **Mitigation**: Connection pooling, parallel command execution, timeout handling
- **Fallback**: Error recovery with exponential backoff

**State Deduplication Complexity**:
- **Mitigation**: Conservative similarity threshold (0.9), manual merge option
- **Fallback**: User-controlled merge decisions

**Graph Scalability**:
- **Mitigation**: Performance monitoring, pagination for large graphs
- **Fallback**: Graceful degradation with filtering

**WebRTC Integration**:
- **Mitigation**: Reuse existing infrastructure, no changes to streaming
- **Fallback**: Discovery panel works without stream (state capture still functional)

### Operational Risks

**Container Resource Limits**:
- **Mitigation**: Memory monitoring, log rotation, cleanup tasks
- **Fallback**: External volume mounting for large datasets

**File System Conflicts**:
- **Mitigation**: Atomic file operations, backup copies, conflict detection
- **Fallback**: User-guided conflict resolution

## Next Steps

### Immediate Actions (Phase 1)

1. **Implement Backend Services**:
   - Create `introspectService.ts` with ADB command execution
   - Implement `graphService.ts` with state management and merging
   - Add API routes in `routes/graph.ts`

2. **Develop Frontend Panel**:
   - Create `DiscoveryPanel.tsx` component
   - Implement `useDiscovery.ts` hook for API integration
   - Update feature flags to enable discovery, disable GPS

3. **Integration and Testing**:
   - Update Docker Compose with data volume
   - Add health endpoints for monitoring
   - Perform end-to-end testing with MaynDrive app

4. **Documentation and Deployment**:
   - Complete user documentation in `quickstart.md`
   - Validate performance targets
   - Prepare for Phase 2 planning

### Phase 2 Preparation (Future)

- Flow DSL specification and implementation
- Intelligent replay algorithms
- Advanced graph visualization
- LLM integration for flow optimization

---

*Implementation plan complete. Ready for Phase 1 development with all technical decisions validated and architecture aligned with existing codebase and constitution requirements.*